Fragen:

- Momentan ermoeglicht cuteness mehr schaden, macht ihn aber nicht zwingend hoeher. Soll das geaendert werden?
- helper.lua in etwas aussagekraeftigeres umbenennen, z.B. objectOrientation.lua oder class.lua oder so?

Ideen:

Komplette Ummodelierung des Spielprinzips:
	Cuties wesentlich kleiner:
		- Ebenen für Cuties einbauen (Jump & Run)
			- Levelelemente wie verschiebbare Kisten, explodierende Fässer etc. 
		- Mehrere Cuties als Gegner mit weniger Leben
		- Fortlaufendes Spiel (Vlt. verschiedene Level bei denen Gegner stärker werden, andere Backgrounds etc.)
		- Level-up System und Shop während des Spiels jederzeit aufrufbar
			- Gegner droppen: 
				- Medipacks
				- Munition ?
				- Items
				- Powerups
			- Gegner bringen XP
			- Gegner droppen Gold

	Itemsystem: 
		Waffen und Passive Items kaufbar für Geld. (Eventuell schwierig so zu implementieren, dass es gut aussieht...)
		Aktiv: 
			Ak-47: 
				Feuert regelmäßig einen Schuss linear in Richtung des Gegners. Schaden 1-2, 2 Sek-Takt?
		Passiv:
			Fettschicht:
				Fügt +20 Leben hinzu.
			Rüstung: 
				Fängt 1 Schaden ab.

Attribute:
	- Kollidieren mit Wänden und Böden, bei zu hoher Geschwindigkeit Schaden?
		- Leicht zu implementieren
		- Mobbelligkeit: Wegstoßung, weniger Abbremsung? Alternativ hinzufügen von Masse.
			-Masse könnte zu schnell op werden.
			
- MONSTERBEAMZ
- Attacken/Funktionen:
	- Dashing
	- Ausweichen durch Shield 
	- Shooting nach Maus
	- Explosives:
		Fässer die bei Schuss explodieren
		Granaten
	- Hammer
Juiciness:
	Wobble bei Aufprall. dynamisch!
	Wobble bei Upgrade, Freudensound

Sounds:
	Treffersound: Zufällige Soundauswahl
	Sounds noch zurechtschneiden
	Hüfpsounds bei Kollision mit Wänden.

Grafik:
	Levels von hässlich zu cute, wie bei den cuties

Steuerung:

	WAD: Bewegen nach oben/rechts/links
	S: Block
	Space: Slowmo starten/stoppen
	Linksklick: Spezialaktion (Schuss, C4 Platzieren...)
	Rechtsklick: Dash

Allgemeines DamageSystem:
	Shot bekommt life, alles bekommt life.
	Im DamageSystem wird generell das Verhalten von 2 Entities die miteinander kollidieren bestimmt. 
		Dann würde man für den Shot ein System machen, bei dem es gelöscht wird, nachdem es mit einer Entity kollidiert, die keine Lifecomponent hat. 
		Sobald die zweite Entity eine LIfecomponentn besitzt, wir automatisch der Schaden übermittelt.
		HIer muss man allerdings aufpassen, da man auch den zweiten Fall mit reinnehmen muss. Es wird nur einmal gefired. Außerdem iset zu beachten, dass wir in dieses System alle Particlesystems reinpacken müssten . 
		Auflösungen werden allgemein Verfasst.


Global Entity für Datensicherung:


		Jo Rafael. Wir müssen uns mal absprechen. Und zwar ist es momentan relativ wichtig zu wissen, ob wir jetzt mit einer globalen Gameplay Component arbeiten oder ob wir weiterhin nur mit lokalem Kram arbeiten und Entities nur über den Engine erreichen. Ich müsste jetzt z.B. ein System schreiben, welches explosons abdeckt. Dafür müsste man allderings einmal durch alle enemies durchiterieren. Entweder muss ich dafür extra ein neues System mit requiredComponents() return {"IsEnemy"} end machen oder einfach eine Table, in der alle Enemies sind. Ich würde eigentlich eher zur Table mit den Enemies tendieren, da wir diese bestimmt noch häufiger brauchen, wollte das dann aber doch mit dir abklären. Außerdem könnten wir da noch Kram wie, Gold, Inventory, Statistics und so nen scheiß reinpacken. Und wir müssen uns noch ein System überlegen, nach dem die Enemies spawnen und nach dem unser Spiel funktionieren soll. Haben wir jetzt ein durchgehendes Spiel, bei dem die Gegner immer stärker werden und das man pausieren kann um einzukaufen oder wollen wir mit Waves arbeiten, bei dem die Gegner hardcoded in Tabellen stehen. Hat alles seine Vor und Nachteile.  


	Gerüst:

		System, das jedes Mal, wenn eine Entity dem System hinzugefügt wird eine Typabfrage durchführt. Wenn eine bestimmte Entity vorhanden ist, wird sie in eine Liste eingetragen. Außerdem beinhaltet dieses System eine Methode, die als Parameter einen String übergeben bekommt und die Liste der jeweiligen Entitygruppe zurückgibt. 



EntityLists = class("Entitylist")

function Entitylist:__init()
	self.IsEnemy = {}
	self.IsShot = {}
end

function EntityLists:checkEntity(entity)
	for index, component in pairs(entity.components) do
		if self.[component.__name] then
			table.insert(self.IsEnemy, entity)
		end
	end
end

function EntityLists:returnGroup(String)
	if self.[String] then
		return self.[String]
	end
end

function EntityLists:removeEntity(entity)
	for index, component in pairs(entity.components) do
		if self.[component.__name] then
			table.remove(self.IsEnemy, entity)
		end
	end
end